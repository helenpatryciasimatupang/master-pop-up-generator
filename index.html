<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Master Pop Up Generator (FINAL â€¢ FAT/FDT by Same Coordinate)</title>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <!-- JSZip (KMZ) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    input { display:block; margin:6px 0; padding:6px; width:360px; }
    button { margin-top:10px; padding:10px 24px; }
    small { color:#666; }
  </style>
</head>
<body>

<h2>Master Pop Up Generator (FINAL)</h2>

<h3>Upload File</h3>
<input type="file" id="dbFile" accept=".xlsx">
<input type="file" id="kmzFile" accept=".kmz">
<small>KMZ untuk LINE (Cable Distribution polyline)</small>

<h3>Input Area</h3>
<input id="area" placeholder="Nama Area">
<input id="district" placeholder="District">
<input id="subdistrict" placeholder="Sub District">
<input id="postcode" placeholder="Post Code">
<input id="fdt" placeholder="FDT Code">
<input id="idarea" placeholder="ID Area">

<button onclick="generate()">Generate Master Pop Up</button>

<script>
// ================= UTIL =================
const normalize = v => String(v ?? '').trim().toUpperCase();

function getLatLon(x,y){
  const X = Number(x), Y = Number(y);
  if (!isFinite(X) || !isFinite(Y)) return {lat:'',lon:''};
  if (Math.abs(X)<=90 && Math.abs(Y)>90) return {lat:X,lon:Y};
  if (Math.abs(Y)<=90 && Math.abs(X)>90) return {lat:Y,lon:X};
  return {lat:X,lon:Y};
}

function setCell(ws,r,c,v){
  ws[XLSX.utils.encode_cell({r,c})] = { t:'s', v:String(v ?? '') };
}

// key koordinat untuk "satu titik"
function coordKey(lat, lon, decimals=6){
  if (!isFinite(lat) || !isFinite(lon)) return '';
  return `${Number(lat).toFixed(decimals)},${Number(lon).toFixed(decimals)}`;
}

// ðŸ”¥ FILTER: hanya "LINE X", kosong jika tidak ada
function filterOnlyLine(text){
  if(!text) return '';
  const out = text.split(',')
    .map(s=>s.trim().toUpperCase())
    .filter(s=>/^LINE\s+[A-Z0-9]+$/.test(s));
  return out.length ? out.join(',') : '';
}

// ================= HEADER =================
const HEADERS = [
  'HOMEPASS_ID','CLUSTER_NAME','PREFIX_ADDRESS','STREET_NAME','HOUSE_NUMBER','BLOCK',
  'FLOOR','RT','RW','DISTRICT','SUB_DISTRICT','FDT_CODE','FAT_CODE',
  'BUILDING_LATITUDE','BUILDING_LONGITUDE','Category BizPass','POST CODE',
  'ADDRESS POLE / FAT','OV_UG','HOUSE_COMMENT_','BUILDING_NAME','TOWER','APTN',
  'FIBER_NODE__HFC_','ID_Area','Clamp_Hook_ID','DEPLOYMENT_TYPE','NEED_SURVEY',
  'Pole ID (New)','Coordinate (Lat) NEW','Coordinate (Long) NEW',
  'Pole Provider (New)','Pole Type','LINE','FAT ID/NETWORK ID',
  'Clamp_Hook_LATITUDE','Clamp_Hook_LONGITUDE'
];

function writeHeader(ws){
  HEADERS.forEach((h,i)=>setCell(ws,0,i,h));
  ws['!ref'] = 'A1:AK5000';
}

// ================= GEO (SEGMENT DISTANCE) =================
const M_PER_DEG_LAT = 111320;
function metersPerDegLon(lat){ return 111320 * Math.cos(lat * Math.PI / 180); }

function distPointToSegMeters(p,a,b){
  const latm = M_PER_DEG_LAT;
  const lonm = metersPerDegLon((a.lat+b.lat)/2 || p.lat);

  const px=p.lon*lonm, py=p.lat*latm;
  const ax=a.lon*lonm, ay=a.lat*latm;
  const bx=b.lon*lonm, by=b.lat*latm;

  const vx=bx-ax, vy=by-ay;
  const wx=px-ax, wy=py-ay;

  const c1=vx*wx+vy*wy;
  if(c1<=0) return Math.hypot(px-ax,py-ay);
  const c2=vx*vx+vy*vy;
  if(c2<=c1) return Math.hypot(px-bx,py-by);
  const t=c1/c2;
  return Math.hypot(px-(ax+t*vx),py-(ay+t*vy));
}

// ================= KMZ PARSER (SEGMENT-BASED) =================
async function parseKMZSegments(file){
  const zip = await JSZip.loadAsync(file);
  const kml = zip.file(/\.kml$/i)[0];
  const text = await kml.async("text");
  const xml = new DOMParser().parseFromString(text,"text/xml");

  const segments=[];
  [...xml.getElementsByTagName("Placemark")].forEach(pm=>{
    const name = pm.getElementsByTagName("name")[0]?.textContent?.trim();
    const coords = pm.getElementsByTagName("coordinates")[0]?.textContent;
    if(!name || !coords) return;

    const pts = coords.trim().split(/\s+/).map(c=>{
      const [lon,lat]=c.split(',').map(Number);
      return isFinite(lat)&&isFinite(lon)?{lat,lon}:null;
    }).filter(Boolean);

    for(let i=0;i<pts.length-1;i++){
      segments.push({name, a:pts[i], b:pts[i+1]});
    }
  });
  return segments;
}

// ================= MAIN =================
async function generate(){
  const db = document.getElementById('dbFile').files[0];
  if(!db) return alert('Upload DATABASE XLSX');
  const kmz = document.getElementById('kmzFile').files[0];

  const A = {
    area: area.value,
    district: district.value,
    subdistrict: subdistrict.value,
    postcode: postcode.value,
    fdt: fdt.value,
    idarea: idarea.value
  };

  const reader = new FileReader();
  reader.onload = async e=>{
    const wb = XLSX.read(e.target.result,{type:'binary'});
    const rows = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);

    const ws={};
    writeHeader(ws);

    let rowHome=1, rowPole=1;

    // ===== HOOK MAP =====
    const hookMap={};
    rows.forEach(r=>{
      if(String(r.FolderPath||'').toUpperCase().includes('/HOOK')){
        hookMap[normalize(r.Name)] = getLatLon(r.X,r.Y);
      }
    });

    // ===== KMZ segments for LINE =====
    const kmzSegs = kmz ? await parseKMZSegments(kmz) : [];
    const TOL = 1.5; // meter

    // ===== BUILD MAP: coord -> (FAT/FDT code) =====
    // ambil dari baris yang FolderPath mengandung /FAT atau /FDT
    // dan pakai kolom r.Name sebagai ID FAT/FDT (umumnya begitu)
    const networkByCoord = {};
    rows.forEach(r=>{
      const fp = String(r.FolderPath||'').toUpperCase();
      if (!fp.includes('/FAT') && !fp.includes('/FDT')) return;

      const c = getLatLon(r.X, r.Y);
      const key = coordKey(c.lat, c.lon, 6);
      if (!key) return;

      const id = (r.Name ?? '').toString().trim();
      if (!id) return;

      // kalau ada beberapa item di titik sama, simpan unik
      if (!networkByCoord[key]) networkByCoord[key] = new Set();
      networkByCoord[key].add(id);
    });

    // convert Set -> string (kalau lebih dari 1, gabung pakai koma)
    Object.keys(networkByCoord).forEach(k=>{
      networkByCoord[k] = [...networkByCoord[k]].join(',');
    });

    // ===== HOME (mulai baris 2) =====
    rows.forEach(r=>{
      const fp=String(r.FolderPath||'');
      if(!fp.includes('/HOME')&&!fp.includes('/HOME-BIZ')) return;

      const house=r.Name||'';
      const block=/^[A-Za-z]\d+/.test(house)?house[0]:'';
      const hc=getLatLon(r.X,r.Y);
      const hookC=hookMap[normalize(r.CLAIM_HOOK)]||{lat:'',lon:''};

      setCell(ws,rowHome,0,'');                 // HOMEPASS_ID kosong
      setCell(ws,rowHome,1,A.area);             // CLUSTER_NAME
      setCell(ws,rowHome,2,'JL.');              // PREFIX_ADDRESS
      setCell(ws,rowHome,3,r.JALAN||'');        // STREET_NAME
      setCell(ws,rowHome,4,house);              // HOUSE_NUMBER
      setCell(ws,rowHome,5,block);              // BLOCK
      setCell(ws,rowHome,6,''); setCell(ws,rowHome,7,''); setCell(ws,rowHome,8,'');
      setCell(ws,rowHome,9,A.district);
      setCell(ws,rowHome,10,A.subdistrict);
      setCell(ws,rowHome,11,A.fdt);
      setCell(ws,rowHome,12,r.FAT||'');         // FAT_CODE (untuk HOME)
      setCell(ws,rowHome,13,hc.lat);
      setCell(ws,rowHome,14,hc.lon);
      setCell(ws,rowHome,15,'');                // Category BizPass
      setCell(ws,rowHome,16,A.postcode);
      setCell(ws,rowHome,17,'');                // ADDRESS POLE / FAT
      setCell(ws,rowHome,18,'O');
      setCell(ws,rowHome,19,'NEED SURVEY');
      setCell(ws,rowHome,20,''); setCell(ws,rowHome,21,''); setCell(ws,rowHome,22,'');
      setCell(ws,rowHome,23,'');
      setCell(ws,rowHome,24,A.idarea);
      setCell(ws,rowHome,25,r.CLAIM_HOOK||'');
      setCell(ws,rowHome,26,'FAT EXT');
      setCell(ws,rowHome,27,'YES');
      // POLE cols AC..AI jangan isi untuk HOME
      setCell(ws,rowHome,35,hookC.lat);
      setCell(ws,rowHome,36,hookC.lon);

      rowHome++;
    });

    // ===== POLE LIST unik & urut =====
    const poleMap={};
    rows.forEach(r=>{
      if(String(r.FolderPath||'').toUpperCase().includes('/POLE')){
        const k=normalize(r.Name);
        if(!poleMap[k]){
          poleMap[k]={name:r.Name,coord:getLatLon(r.X,r.Y)};
        }
      }
    });

    Object.values(poleMap)
      .sort((a,b)=>a.name.localeCompare(b.name,undefined,{numeric:true}))
      .forEach(p=>{
        // LINE dari KMZ (segment-based)
        let found=new Set();
        if(isFinite(p.coord.lat)&&isFinite(p.coord.lon)){
          kmzSegs.forEach(s=>{
            if(distPointToSegMeters({lat:p.coord.lat,lon:p.coord.lon},s.a,s.b)<=TOL){
              found.add(s.name);
            }
          });
        }
        const rawLine = found.size ? [...found].join(',') : '';
        const finalLine = filterOnlyLine(rawLine); // hanya LINE, kosong jika tidak ada

        // FAT ID/NETWORK ID: hanya kalau ada FAT/FDT yang koordinatnya SAMA dengan POLE
        const pKey = coordKey(p.coord.lat, p.coord.lon, 6);
        const networkId = (pKey && networkByCoord[pKey]) ? networkByCoord[pKey] : '';

        setCell(ws,rowPole,28,p.name);           // Pole ID (New)
        setCell(ws,rowPole,29,p.coord.lat);      // Coordinate (Lat) NEW
        setCell(ws,rowPole,30,p.coord.lon);      // Coordinate (Long) NEW
        setCell(ws,rowPole,31,'LN (Existing)');  // Pole Provider (New)
        setCell(ws,rowPole,32,'Pole 7/250');     // Pole Type
        setCell(ws,rowPole,33,finalLine);        // LINE (kosong kalau tidak ada)
        setCell(ws,rowPole,34,networkId);        // FAT ID/NETWORK ID (kosong kalau tidak ada yg sama koordinat)

        rowPole++;
      });

    const outWB=XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(outWB,ws,'MASTER_POP_UP');
    XLSX.writeFile(outWB,'MASTER_POP_UP.xlsx');
  };

  reader.readAsBinaryString(db);
}
</script>

</body>
</html>
